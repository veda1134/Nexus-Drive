<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">  
    <title>NexusFlow: White Interceptor</title>  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>  
    <script src="https://cdn.tailwindcss.com"></script>  
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1234567890123456" crossorigin="anonymous"></script>
    <script>
        // Initialize Google Ads queue
        window.adsbygoogle = window.adsbygoogle || [];
        var adConfig = function(o) { adsbygoogle.push(o); }

        // Configure the ads (Turn on sound, set pre-load)
        adConfig({
            preloadAdBreaks: 'on',
            sound: 'on', 
            onReady: () => console.log("Ads Ready") 
        });
    </script>

    <style>  
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Inter', sans-serif; }  
        canvas { display: block; }  
        .glass { background: rgba(18, 12, 12, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(236, 19, 19, 0.3); }  
        * { touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }  
    </style>  
</head>  
<body>  

<div id="hud" class="absolute top-6 left-6 text-white z-10 pointer-events-none">  
    <h1 class="text-3xl font-bold tracking-tighter text-red-600 italic">NEXUS<span class="text-white">FLOW</span></h1>  
    <div id="statusPanel" class="mt-4 glass p-4 rounded-lg min-w-[180px]">  
        <p id="statusText" class="text-[10px] font-mono text-green-400 font-bold mb-2 tracking-widest uppercase">Engine: Powered</p>  
        <div class="w-full bg-white/10 h-1.5 rounded-full overflow-hidden mb-4">  
            <div id="boostBar" class="bg-cyan-400 h-full w-0 transition-all duration-100"></div>  
        </div>  
        <p id="distance" class="text-2xl font-mono">0m</p>  
    </div>  
</div>  

<div id="restartScreen" class="absolute inset-0 flex items-center justify-center bg-black/95 z-50 hidden p-6">  
    <div class="glass p-10 rounded-2xl text-center w-full max-w-sm border-red-600">  
        <h2 class="text-4xl font-black text-red-600 mb-2 italic tracking-tighter text-primary">UNIT OFFLINE</h2>  
        <p id="finalScore" class="text-white font-mono text-lg mb-8">0m</p>  
        <button onclick="showAdAndRestart()" class="w-full py-4 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg transition-all active:scale-95">  
            RE-INITIALIZE  
        </button>  
    </div>  
</div>  

<script>  
    let isAlive = true;  
    let baseSpeed = 0.7;  
    let currentSpeed = 0.7;  
    let distance = 0;  
    let obstacles = [], gates = [];  
    let boostTimer = 0;  
    const input = { left: false, right: false };  
    
    // --- CONFIGURATION ---
    const PLAY_WIDTH = 50; 
    const BOUNDARY_LIMIT = 23; 

    // --- 1. ENGINE ---  
    const scene = new THREE.Scene();  
    scene.fog = new THREE.Fog(0x0a0a0a, 20, 120);  
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);  
    const renderer = new THREE.WebGLRenderer({ antialias: true });  
    renderer.setSize(window.innerWidth, window.innerHeight);  
    renderer.setPixelRatio(window.devicePixelRatio);  
    document.body.appendChild(renderer.domElement);  

    // --- 2. BRIGHT STEALTH INTERCEPTOR ---  
    const ship = new THREE.Group();  
    const matBright = new THREE.MeshStandardMaterial({   
        color: 0xe0e0e0,   
        roughness: 0.1,   
        metalness: 0.8,  
        emissive: 0xffffff,  
        emissiveIntensity: 0.05   
    });  
    const matGlow = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xec1313, emissiveIntensity: 3 });  

    const body = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.45, 2.6), matBright);  
    ship.add(body);  

    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.35, 1.2, 4), matBright);  
    nose.rotation.x = -Math.PI / 2;  
    nose.position.z = -1.8;  
    ship.add(nose);  

    const wingShape = new THREE.Shape();  
    wingShape.moveTo(0,0);  
    wingShape.lineTo(2.8, -1.8);  
    wingShape.lineTo(2.8, -0.6);  
    wingShape.lineTo(0, 1.2);  
    const wingGeo = new THREE.ExtrudeGeometry(wingShape, { depth: 0.15, bevelEnabled: false });  
      
    const leftWing = new THREE.Mesh(wingGeo, matBright);  
    leftWing.rotation.x = Math.PI / 2;  
    leftWing.position.set(-0.32, 0, 0.6);  
    ship.add(leftWing);  

    const rightWing = new THREE.Mesh(wingGeo, matBright);  
    rightWing.rotation.x = Math.PI / 2;  
    rightWing.rotation.y = Math.PI;  
    rightWing.position.set(0.32, 0, 0.6);  
    ship.add(rightWing);  

    const thruster = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.1, 0.5, 12), matGlow);  
    thruster.rotation.x = Math.PI/2;  
    thruster.position.set(0, 0, 1.3);  
    ship.add(thruster);  

    scene.add(ship);  
    ship.position.y = 0.5;  

    // --- 3. TRAIL ---  
    const trailCount = 45;  
    const trailPositions = new Float32Array(trailCount * 3);  
    const trailGeo = new THREE.BufferGeometry();  
    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));  
    const trailMat = new THREE.PointsMaterial({ size: 0.25, color: 0xec1313, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });  
    const trail = new THREE.Points(trailGeo, trailMat);  
    scene.add(trail);  
    let trailHistory = [];  

    // --- 4. WORLD LIGHTING ---  
    const shipLight = new THREE.PointLight(0xffffff, 200, 40);  
    shipLight.position.set(0, 2, 0);  
    ship.add(shipLight);  

    const globalLight = new THREE.AmbientLight(0x666666);  
    scene.add(globalLight);  

    const grid = new THREE.GridHelper(2000, 100, 0x444444, 0x222222);  
    scene.add(grid);  

    // --- 5. CONTROLS ---  
    const handleInput = (state, isLeft, isTouch = false) => {  
        if (isTouch) {  
            input.left = state && isLeft;  
            input.right = state && !isLeft;  
        } else {  
            if (isLeft) input.left = state; else input.right = state;  
        }  
    };  

    window.addEventListener('keydown', (e) => {  
        const k = e.key.toLowerCase();  
        if (k === 'a' || k === 'arrowleft') handleInput(true, true);  
        if (k === 'd' || k === 'arrowright') handleInput(true, false);  
    });  
    window.addEventListener('keyup', (e) => {  
        const k = e.key.toLowerCase();  
        if (k === 'a' || k === 'arrowleft') handleInput(false, true);  
        if (k === 'd' || k === 'arrowright') handleInput(false, false);  
    });  

    window.addEventListener('touchstart', (e) => {  
        const x = e.touches[0].clientX;  
        handleInput(true, x < window.innerWidth/2, true);  
    }, { passive: false });  
    window.addEventListener('touchend', () => { handleInput(false, false, true); });  

    // --- 6. SPAWNER (FIXED) ---  
    function spawn() {  
        if (!isAlive) return;  
        // FIX: Spawning logic uses world width, not ship position
        const x = (Math.random() - 0.5) * PLAY_WIDTH; 
        const z = ship.position.z - 140;  
          
        if (Math.random() > 0.8) {  
            const g = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.15, 16, 32), new THREE.MeshStandardMaterial({ color: 0x00f2ff, emissive: 0x00f2ff, emissiveIntensity: 2 }));  
            g.position.set(x, 2.5, z);  
            scene.add(g);  
            gates.push(g);  
        } else {  
            const o = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshStandardMaterial({ color: 0xec1313, emissive: 0xec1313, emissiveIntensity: 1 }));  
            o.position.set(x, 1.25, z);  
            scene.add(o);  
            obstacles.push(o);  
        }  
        setTimeout(spawn, Math.max(70, 700 - (distance * 0.4)));  
    }  
    spawn();  

    // --- 7. ANIMATION ---  
    function animate() {  
        if (!isAlive) return;  
        requestAnimationFrame(animate);  

        if (boostTimer > 0) {  
            currentSpeed = baseSpeed * 2.1;  
            boostTimer--;  
            trailMat.color.setHex(0x00f2ff);  
            shipLight.color.setHex(0x00f2ff);  
            document.getElementById('boostBar').style.width = (boostTimer/1.8) + "%";  
        } else {  
            currentSpeed = baseSpeed;  
            trailMat.color.setHex(0xec1313);  
            shipLight.color.setHex(0xffffff);  
            document.getElementById('boostBar').style.width = "0%";  
        }  

        ship.position.z -= currentSpeed;  
        distance += currentSpeed;  
        baseSpeed += 0.0001;  

        // MOVEMENT
        if (input.left) {  
            ship.position.x -= 0.38;  
            ship.rotation.z = THREE.MathUtils.lerp(ship.rotation.z, 0.75, 0.1);  
        } else if (input.right) {  
            ship.position.x += 0.38;  
            ship.rotation.z = THREE.MathUtils.lerp(ship.rotation.z, -0.75, 0.1);  
        } else {  
            ship.rotation.z = THREE.MathUtils.lerp(ship.rotation.z, 0, 0.1);  
        }  

        // FIX: Boundary clamping preventing flying off screen
        ship.position.x = Math.max(-BOUNDARY_LIMIT, Math.min(BOUNDARY_LIMIT, ship.position.x));

        camera.position.lerp(new THREE.Vector3(ship.position.x, 5, ship.position.z + 14), 0.12);  
        camera.lookAt(ship.position.x, 1.2, ship.position.z - 12);  

        trailHistory.push({ x: ship.position.x, y: ship.position.y, z: ship.position.z + 1 });  
        if (trailHistory.length > trailCount) trailHistory.shift();  
        for (let i = 0; i < trailHistory.length; i++) {  
            trailPositions[i * 3] = trailHistory[i].x;  
            trailPositions[i * 3 + 1] = trailHistory[i].y;  
            trailPositions[i * 3 + 2] = trailHistory[i].z;  
        }  
        trail.geometry.attributes.position.needsUpdate = true;  

        grid.position.z = ship.position.z - (ship.position.z % 20);  
        grid.position.x = ship.position.x - (ship.position.x % 20);  
        document.getElementById('distance').innerText = Math.floor(distance) + "m";  

        const sBox = new THREE.Box3().setFromObject(ship);  
        obstacles.forEach((o, i) => {  
            if (sBox.intersectsBox(new THREE.Box3().setFromObject(o))) {  
                isAlive = false;  
                if (navigator.vibrate) navigator.vibrate(200);  
                document.getElementById('restartScreen').classList.remove('hidden');  
                document.getElementById('finalScore').innerText = Math.floor(distance) + "m";  
            }  
        });  
        gates.forEach((g, i) => {  
            if (sBox.intersectsBox(new THREE.Box3().setFromObject(g))) {  
                boostTimer = 180;  
                scene.remove(g);  
                gates.splice(i, 1);  
            }  
        });  

        renderer.render(scene, camera);  
    }  

    animate();  
    window.addEventListener('resize', () => {  
        camera.aspect = window.innerWidth / window.innerHeight;  
        camera.updateProjectionMatrix();  
        renderer.setSize(window.innerWidth, window.innerHeight);  
    });  

    // --- 8. AD INTEGRATION FUNCTION ---
    function showAdAndRestart() {
        console.log("Attempting to show ad...");
        
        // Check if the adBreak function exists (provided by Google script)
        if (typeof adBreak === 'function') {
            adBreak({
                type: 'next',  // "Next" level or restart
                name: 'restart_game',
                beforeAd: () => { 
                    console.log("Ad starting - Muting audio/pausing game"); 
                    // Add your sound mute logic here if you add music later
                },
                afterAd: () => { 
                    console.log("Ad finished"); 
                },
                adBreakDone: () => { 
                    // This runs whether the ad showed or not (e.g. no internet)
                    console.log("Reloading game...");
                    location.reload(); 
                }
            });
        } else {
            // Fallback if ads fail or aren't loaded (e.g., testing locally)
            console.log("Ad API not found, reloading directly.");
            location.reload();
        }
    }
</script>

</body>  
</html>
